C51 COMPILER V9.01   U8G2_FONT                                                             04/30/2021 10:55:17 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE U8G2_FONT
OBJECT MODULE PLACED IN .\Objects\u8g2_font.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE ..\u8g2\csrc\u8g2_font.c LARGE WARNINGLEVEL(1) OPTIMIZE(8,SPEED) BROWSE 
                    -INCDIR(..\USER;..\SYS;..\BSP\BSP_485;..\BSP\BSP_ADC;..\BSP\BSP_KEY;..\BSP\BSP_OLED_IIC;..\APP) DEBUG OBJECTEXTEND PRINT(
                    -.\Listings\u8g2_font.lst) TABS(2) OBJECT(.\Objects\u8g2_font.obj)

line level    source

   1          /*
   2          
   3            u8g2_font.c
   4          
   5            Universal 8bit Graphics Library (https://github.com/olikraus/u8g2/)
   6          
   7            Copyright (c) 2016, olikraus@gmail.com
   8            All rights reserved.
   9          
  10            Redistribution and use in source and binary forms, with or without modification, 
  11            are permitted provided that the following conditions are met:
  12          
  13            * Redistributions of source code must retain the above copyright notice, this list 
  14              of conditions and the following disclaimer.
  15              
  16            * Redistributions in binary form must reproduce the above copyright notice, this 
  17              list of conditions and the following disclaimer in the documentation and/or other 
  18              materials provided with the distribution.
  19          
  20            THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND 
  21            CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
  22            INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
  23            MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
  24            DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR 
  25            CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
  26            SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
  27            NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
  28            LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
  29            CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, 
  30            STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  31            ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF 
  32            ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  
  33          
  34          */
  35          
  36          #include "u8g2.h"
*** ERROR C141 IN LINE 600 OF ..\U8G2\CSRC\U8X8.H: syntax error near ')'
*** ERROR C141 IN LINE 632 OF ..\U8G2\CSRC\U8X8.H: syntax error near ')'
*** ERROR C141 IN LINE 663 OF ..\U8G2\CSRC\U8X8.H: syntax error near ')'
  37          
  38          /* size of the font data structure, there is no struct or class... */
  39          /* this is the size for the new font format */
  40          #define U8G2_FONT_DATA_STRUCT_SIZE 23
  41          
  42          /*
  43            font data:
  44          
  45            offset  bytes description
  46            0   1   glyph_cnt   number of glyphs
  47            1   1   bbx_mode  0: proportional, 1: common height, 2: monospace, 3: multiple of 8
  48            2   1   bits_per_0  glyph rle parameter
  49            3   1   bits_per_1  glyph rle parameter
  50          
C51 COMPILER V9.01   U8G2_FONT                                                             04/30/2021 10:55:17 PAGE 2   

  51            4   1   bits_per_char_width   glyph rle parameter
  52            5   1   bits_per_char_height  glyph rle parameter
  53            6   1   bits_per_char_x   glyph rle parameter
  54            7   1   bits_per_char_y   glyph rle parameter
  55            8   1   bits_per_delta_x    glyph rle parameter
  56          
  57            9   1   max_char_width
  58            10    1   max_char_height
  59            11    1   x offset
  60            12    1   y offset (descent)
  61            
  62            13    1   ascent (capital A)
  63            14    1   descent (lower g)
  64            15    1   ascent '('
  65            16    1   descent ')'
  66            
  67            17    1   start pos 'A' high byte
  68            18    1   start pos 'A' low byte
  69          
  70            19    1   start pos 'a' high byte
  71            20    1   start pos 'a' low byte
  72          
  73            21    1   start pos unicode high byte
  74            22    1   start pos unicode low byte
  75          
  76            Font build mode, 0: proportional, 1: common height, 2: monospace, 3: multiple of 8
  77          
  78            Font build mode 0:    
  79              - "t"
  80              - Ref height mode: U8G2_FONT_HEIGHT_MODE_TEXT, U8G2_FONT_HEIGHT_MODE_XTEXT or U8G2_FONT_HEIGHT_MODE_AL
             -L
  81              - use in transparent mode only (does not look good in solid mode)
  82              - most compact format
  83              - different font heights possible
  84              
  85            Font build mode 1:    
  86              - "h"
  87              - Ref height mode: U8G2_FONT_HEIGHT_MODE_ALL
  88              - transparent or solid mode
  89              - The height of the glyphs depend on the largest glyph in the font. This means font height depends on 
             -postfix "r", "f" and "n".
  90          
  91          */
  92          
  93          /* use case: What is the width and the height of the minimal box into which string s fints? */
  94          void u8g2_font_GetStrSize(const void *font, const char *s, u8g2_uint_t *width, u8g2_uint_t *height);
  95          void u8g2_font_GetStrSizeP(const void *font, const char *s, u8g2_uint_t *width, u8g2_uint_t *height);
  96          
  97          /* use case: lower left edge of a minimal box is known, what is the correct x, y position for the string d
             -raw procedure */
  98          void u8g2_font_AdjustXYToDraw(const void *font, const char *s, u8g2_uint_t *x, u8g2_uint_t *y);
  99          void u8g2_font_AdjustXYToDrawP(const void *font, const char *s, u8g2_uint_t *x, u8g2_uint_t *y);
 100          
 101          /* use case: Baseline origin known, return minimal box */
 102          void u8g2_font_GetStrMinBox(u8g2_t *u8g2, const void *font, const char *s, u8g2_uint_t *x, u8g2_uint_t *y,
             - u8g2_uint_t *width, u8g2_uint_t *height);
 103          
 104          /* procedures */
 105          
 106          /*========================================================================*/
 107          /* low level byte and word access */
 108          
C51 COMPILER V9.01   U8G2_FONT                                                             04/30/2021 10:55:17 PAGE 3   

 109          /* removed NOINLINE, because it leads to smaller code, might also be faster */
 110          //static uint8_t u8g2_font_get_byte(const uint8_t *font, uint8_t offset) U8G2_NOINLINE;
 111          static uint8_t u8g2_font_get_byte(const uint8_t *font, uint8_t offset)
 112          {
 113   1        font += offset;
 114   1        return u8x8_pgm_read( font );  
 115   1      }
 116          
 117          static uint16_t u8g2_font_get_word(const uint8_t *font, uint8_t offset) U8G2_NOINLINE; 
 118          static uint16_t u8g2_font_get_word(const uint8_t *font, uint8_t offset)
 119          {
 120   1          uint16_t pos;
 121   1          font += offset;
 122   1          pos = u8x8_pgm_read( font );
 123   1          font++;
 124   1          pos <<= 8;
 125   1          pos += u8x8_pgm_read( font);
 126   1          return pos;
 127   1      }
 128          
 129          /*========================================================================*/
 130          /* new font format */
 131          void u8g2_read_font_info(u8g2_font_info_t *font_info, const uint8_t *font)
 132          {
 133   1        /* offset 0 */
 134   1        font_info->glyph_cnt = u8g2_font_get_byte(font, 0);
 135   1        font_info->bbx_mode = u8g2_font_get_byte(font, 1);
 136   1        font_info->bits_per_0 = u8g2_font_get_byte(font, 2);
 137   1        font_info->bits_per_1 = u8g2_font_get_byte(font, 3);
 138   1        
 139   1        /* offset 4 */
 140   1        font_info->bits_per_char_width = u8g2_font_get_byte(font, 4);
 141   1        font_info->bits_per_char_height = u8g2_font_get_byte(font, 5);
 142   1        font_info->bits_per_char_x = u8g2_font_get_byte(font, 6);
 143   1        font_info->bits_per_char_y = u8g2_font_get_byte(font, 7);
 144   1        font_info->bits_per_delta_x = u8g2_font_get_byte(font, 8);
 145   1        
 146   1        /* offset 9 */
 147   1        font_info->max_char_width = u8g2_font_get_byte(font, 9);
 148   1        font_info->max_char_height = u8g2_font_get_byte(font, 10);
 149   1        font_info->x_offset = u8g2_font_get_byte(font, 11);
 150   1        font_info->y_offset = u8g2_font_get_byte(font, 12);
 151   1        
 152   1        /* offset 13 */
 153   1        font_info->ascent_A = u8g2_font_get_byte(font, 13);
 154   1        font_info->descent_g = u8g2_font_get_byte(font, 14);
 155   1        font_info->ascent_para = u8g2_font_get_byte(font, 15);
 156   1        font_info->descent_para = u8g2_font_get_byte(font, 16);
 157   1        
 158   1        /* offset 17 */
 159   1        font_info->start_pos_upper_A = u8g2_font_get_word(font, 17);
 160   1        font_info->start_pos_lower_a = u8g2_font_get_word(font, 19); 
 161   1        
 162   1        /* offset 21 */
 163   1      #ifdef U8G2_WITH_UNICODE
 164   1        font_info->start_pos_unicode = u8g2_font_get_word(font, 21); 
 165   1      #endif
 166   1      }
 167          
 168          
 169          /* calculate the overall length of the font, only used to create the picture for the google wiki */
 170          size_t u8g2_GetFontSize(const uint8_t *font_arg)
C51 COMPILER V9.01   U8G2_FONT                                                             04/30/2021 10:55:17 PAGE 4   

 171          {
 172   1        uint16_t e;
 173   1        const uint8_t *font = font_arg;
 174   1        font += U8G2_FONT_DATA_STRUCT_SIZE;
 175   1        
 176   1        for(;;)
 177   1        {
 178   2          if ( u8x8_pgm_read( font + 1 ) == 0 )
 179   2            break;
 180   2          font += u8x8_pgm_read( font + 1 );
 181   2        }
 182   1        
 183   1        /* continue with unicode section */
 184   1        font += 2;
 185   1      
 186   1        /* skip unicode lookup table */
 187   1        font += u8g2_font_get_word(font, 0);
 188   1        
 189   1        for(;;)
 190   1        {
 191   2          e = u8x8_pgm_read( font );
 192   2          e <<= 8;
 193   2          e |= u8x8_pgm_read( font + 1 );
 194   2          if ( e == 0 )
 195   2            break;
 196   2          font += u8x8_pgm_read( font + 2 );    
 197   2        }
 198   1        
 199   1        return (font - font_arg) + 2;
 200   1      }
 201          
 202          /*========================================================================*/
 203          /* u8g2 interface, font access */
 204          
 205          uint8_t u8g2_GetFontBBXWidth(u8g2_t *u8g2)
 206          {
 207   1        return u8g2->font_info.max_char_width;    /* new font info structure */
 208   1      }
 209          
 210          uint8_t u8g2_GetFontBBXHeight(u8g2_t *u8g2)
 211          {
 212   1        return u8g2->font_info.max_char_height;   /* new font info structure */
 213   1      }
 214          
 215          int8_t u8g2_GetFontBBXOffX(u8g2_t *u8g2) U8G2_NOINLINE;
 216          int8_t u8g2_GetFontBBXOffX(u8g2_t *u8g2)
 217          {
 218   1        return u8g2->font_info.x_offset;    /* new font info structure */
 219   1      }
 220          
 221          int8_t u8g2_GetFontBBXOffY(u8g2_t *u8g2) U8G2_NOINLINE;
 222          int8_t u8g2_GetFontBBXOffY(u8g2_t *u8g2)
 223          {
 224   1        return u8g2->font_info.y_offset;    /* new font info structure */
 225   1      }
 226          
 227          uint8_t u8g2_GetFontCapitalAHeight(u8g2_t *u8g2) U8G2_NOINLINE; 
 228          uint8_t u8g2_GetFontCapitalAHeight(u8g2_t *u8g2)
 229          {
 230   1        return u8g2->font_info.ascent_A;    /* new font info structure */
 231   1      }
 232          
C51 COMPILER V9.01   U8G2_FONT                                                             04/30/2021 10:55:17 PAGE 5   

 233          /*========================================================================*/
 234          /* glyph handling */
 235          
 236          /* optimized */
 237          uint8_t u8g2_font_decode_get_unsigned_bits(u8g2_font_decode_t *f, uint8_t cnt) 
 238          {
 239   1        uint8_t val;
 240   1        uint8_t bit_pos = f->decode_bit_pos;
 241   1        uint8_t bit_pos_plus_cnt;
 242   1        
 243   1        //val = *(f->decode_ptr);
 244   1        val = u8x8_pgm_read( f->decode_ptr );  
 245   1        
 246   1        val >>= bit_pos;
 247   1        bit_pos_plus_cnt = bit_pos;
 248   1        bit_pos_plus_cnt += cnt;
 249   1        if ( bit_pos_plus_cnt >= 8 )
 250   1        {
 251   2          uint8_t s = 8;
 252   2          s -= bit_pos;
 253   2          f->decode_ptr++;
 254   2          //val |= *(f->decode_ptr) << (8-bit_pos);
 255   2          val |= u8x8_pgm_read( f->decode_ptr ) << (s);
 256   2          //bit_pos -= 8;
 257   2          bit_pos_plus_cnt -= 8;
 258   2        }
 259   1        val &= (1U<<cnt)-1;
 260   1        //bit_pos += cnt;
 261   1        
 262   1        f->decode_bit_pos = bit_pos_plus_cnt;
 263   1        return val;
 264   1      }
 265          
 266          
 267          /*
 268              2 bit --> cnt = 2
 269                -2,-1,0. 1
 270          
 271              3 bit --> cnt = 3
 272                -2,-1,0. 1
 273                -4,-3,-2,-1,0,1,2,3
 274          
 275                if ( x < 0 )
 276            r = bits(x-1)+1;
 277              else
 278            r = bits(x)+1;
 279          
 280          */
 281          /* optimized */
 282          int8_t u8g2_font_decode_get_signed_bits(u8g2_font_decode_t *f, uint8_t cnt)
 283          {
 284   1        int8_t v, d;
 285   1        v = (int8_t)u8g2_font_decode_get_unsigned_bits(f, cnt);
 286   1        d = 1;
 287   1        cnt--;
 288   1        d <<= cnt;
 289   1        v -= d;
 290   1        return v;
 291   1        //return (int8_t)u8g2_font_decode_get_unsigned_bits(f, cnt) - ((1<<cnt)>>1);
 292   1      }
 293          
 294          
C51 COMPILER V9.01   U8G2_FONT                                                             04/30/2021 10:55:17 PAGE 6   

 295          #ifdef U8G2_WITH_FONT_ROTATION
 296          static u8g2_uint_t u8g2_add_vector_y(u8g2_uint_t dy, int8_t x, int8_t y, uint8_t dir) U8G2_NOINLINE;
 297          static u8g2_uint_t u8g2_add_vector_y(u8g2_uint_t dy, int8_t x, int8_t y, uint8_t dir)
 298          {
 299   1        switch(dir)
 300   1        {
 301   2          case 0:
 302   2            dy += y;
 303   2            break;
 304   2          case 1:
 305   2            dy += x;
 306   2            break;
 307   2          case 2:
 308   2            dy -= y;
 309   2            break;
 310   2          default:
 311   2            dy -= x;
 312   2            break;      
 313   2        }
 314   1        return dy;
 315   1      }
 316          
 317          static u8g2_uint_t u8g2_add_vector_x(u8g2_uint_t dx, int8_t x, int8_t y, uint8_t dir) U8G2_NOINLINE;
 318          static u8g2_uint_t u8g2_add_vector_x(u8g2_uint_t dx, int8_t x, int8_t y, uint8_t dir)
 319          {
 320   1        switch(dir)
 321   1        {
 322   2          case 0:
 323   2            dx += x;
 324   2            break;
 325   2          case 1:
 326   2            dx -= y;
 327   2            break;
 328   2          case 2:
 329   2            dx -= x;
 330   2            break;
 331   2          default:
 332   2            dx += y;
 333   2            break;      
 334   2        }
 335   1        return dx;
 336   1      }
 337          #endif
 338          
 339          
 340          
 341          /*
 342            Description:
 343              Draw a run-length area of the glyph. "len" can have any size and the line
 344              length has to be wrapped at the glyph border.
 345            Args:
 346              len:          Length of the line
 347              is_foreground     foreground/background?
 348              u8g2->font_decode.target_x    X position
 349              u8g2->font_decode.target_y    Y position
 350              u8g2->font_decode.is_transparent  Transparent mode
 351            Return:
 352              -
 353            Calls:
 354              u8g2_Draw90Line()
 355            Called by:
 356              u8g2_font_decode_glyph()
C51 COMPILER V9.01   U8G2_FONT                                                             04/30/2021 10:55:17 PAGE 7   

 357          */
 358          /* optimized */
 359          void u8g2_font_decode_len(u8g2_t *u8g2, uint8_t len, uint8_t is_foreground)
 360          {
 361   1        uint8_t cnt;  /* total number of remaining pixels, which have to be drawn */
 362   1        uint8_t rem;  /* remaining pixel to the right edge of the glyph */
 363   1        uint8_t current;  /* number of pixels, which need to be drawn for the draw procedure */
 364   1          /* current is either equal to cnt or equal to rem */
 365   1        
 366   1        /* local coordinates of the glyph */
 367   1        uint8_t lx,ly;
 368   1        
 369   1        /* target position on the screen */
 370   1        u8g2_uint_t x, y;
 371   1        
 372   1        u8g2_font_decode_t *decode = &(u8g2->font_decode);
 373   1        
 374   1        cnt = len;
 375   1        
 376   1        /* get the local position */
 377   1        lx = decode->x;
 378   1        ly = decode->y;
 379   1        
 380   1        for(;;)
 381   1        {
 382   2          /* calculate the number of pixel to the right edge of the glyph */
 383   2          rem = decode->glyph_width;
 384   2          rem -= lx;
 385   2          
 386   2          /* calculate how many pixel to draw. This is either to the right edge */
 387   2          /* or lesser, if not enough pixel are left */
 388   2          current = rem;
 389   2          if ( cnt < rem )
 390   2            current = cnt;
 391   2          
 392   2          
 393   2          /* now draw the line, but apply the rotation around the glyph target position */
 394   2          //u8g2_font_decode_draw_pixel(u8g2, lx,ly,current, is_foreground);
 395   2      
 396   2          /* get target position */
 397   2          x = decode->target_x;
 398   2          y = decode->target_y;
 399   2      
 400   2          /* apply rotation */
 401   2      #ifdef U8G2_WITH_FONT_ROTATION
 402   2          x = u8g2_add_vector_x(x, lx, ly, decode->dir);
 403   2          y = u8g2_add_vector_y(y, lx, ly, decode->dir);
 404   2      #else
                  x += lx;
                  y += ly;
              #endif
 408   2          
 409   2          /* draw foreground and background (if required) */
 410   2          if ( is_foreground )
 411   2          {
 412   3            u8g2->draw_color = decode->fg_color;      /* draw_color will be restored later */
 413   3            u8g2_DrawHVLine(u8g2, 
 414   3        x, 
 415   3        y, 
 416   3        current, 
 417   3      #ifdef U8G2_WITH_FONT_ROTATION
 418   3        /* dir */ decode->dir
C51 COMPILER V9.01   U8G2_FONT                                                             04/30/2021 10:55:17 PAGE 8   

 419   3      #else
                0
              #endif
 422   3            );
 423   3          }
 424   2          else if ( decode->is_transparent == 0 )    
 425   2          {
 426   3            u8g2->draw_color = decode->bg_color;      /* draw_color will be restored later */
 427   3            u8g2_DrawHVLine(u8g2, 
 428   3        x, 
 429   3        y, 
 430   3        current, 
 431   3      #ifdef U8G2_WITH_FONT_ROTATION
 432   3        /* dir */ decode->dir
 433   3      #else
                0
              #endif
 436   3            );   
 437   3          }
 438   2          
 439   2          /* check, whether the end of the run length code has been reached */
 440   2          if ( cnt < rem )
 441   2            break;
 442   2          cnt -= rem;
 443   2          lx = 0;
 444   2          ly++;
 445   2        }
 446   1        lx += cnt;
 447   1        
 448   1        decode->x = lx;
 449   1        decode->y = ly;
 450   1        
 451   1      }
 452          
 453          static void u8g2_font_setup_decode(u8g2_t *u8g2, const uint8_t *glyph_data)
 454          {
 455   1        u8g2_font_decode_t *decode = &(u8g2->font_decode);
 456   1        decode->decode_ptr = glyph_data;
 457   1        decode->decode_bit_pos = 0;
 458   1        
 459   1        /* 8 Nov 2015, this is already done in the glyph data search procedure */
 460   1        /*
 461   1        decode->decode_ptr += 1;
 462   1        decode->decode_ptr += 1;
 463   1        */
 464   1        
 465   1        decode->glyph_width = u8g2_font_decode_get_unsigned_bits(decode, u8g2->font_info.bits_per_char_width);
 466   1        decode->glyph_height = u8g2_font_decode_get_unsigned_bits(decode,u8g2->font_info.bits_per_char_height);
 467   1        
 468   1        decode->fg_color = u8g2->draw_color;
 469   1        decode->bg_color = (decode->fg_color == 0 ? 1 : 0);
 470   1      }
 471          
 472          
 473          /*
 474            Description:
 475              Decode and draw a glyph.
 476            Args:
 477              glyph_data:           Pointer to the compressed glyph data of the font
 478              u8g2->font_decode.target_x    X position
 479              u8g2->font_decode.target_y    Y position
 480              u8g2->font_decode.is_transparent  Transparent mode
C51 COMPILER V9.01   U8G2_FONT                                                             04/30/2021 10:55:17 PAGE 9   

 481            Return:
 482              Width (delta x advance) of the glyph.
 483            Calls:
 484              u8g2_font_decode_len()
 485          */
 486          /* optimized */
 487          int8_t u8g2_font_decode_glyph(u8g2_t *u8g2, const uint8_t *glyph_data)
 488          {
 489   1        uint8_t a, b;
 490   1        int8_t x, y;
 491   1        int8_t d;
 492   1        int8_t h;
 493   1        u8g2_font_decode_t *decode = &(u8g2->font_decode);
 494   1          
 495   1        u8g2_font_setup_decode(u8g2, glyph_data);
 496   1        h = u8g2->font_decode.glyph_height;
 497   1        
 498   1        x = u8g2_font_decode_get_signed_bits(decode, u8g2->font_info.bits_per_char_x);
 499   1        y = u8g2_font_decode_get_signed_bits(decode, u8g2->font_info.bits_per_char_y);
 500   1        d = u8g2_font_decode_get_signed_bits(decode, u8g2->font_info.bits_per_delta_x);
 501   1        
 502   1        if ( decode->glyph_width > 0 )
 503   1        {
 504   2      #ifdef U8G2_WITH_FONT_ROTATION
 505   2          decode->target_x = u8g2_add_vector_x(decode->target_x, x, -(h+y), decode->dir);
 506   2          decode->target_y = u8g2_add_vector_y(decode->target_y, x, -(h+y), decode->dir);
 507   2      #else
                  decode->target_x += x;
                  decode->target_y -= h+y;
              #endif
 511   2          //u8g2_add_vector(&(decode->target_x), &(decode->target_y), x, -(h+y), decode->dir);
 512   2      
 513   2      #ifdef U8G2_WITH_INTERSECTION
 514   2          {
 515   3            u8g2_uint_t x0, x1, y0, y1;
 516   3            x0 = decode->target_x;
 517   3            y0 = decode->target_y;
 518   3            x1 = x0;
 519   3            y1 = y0;
 520   3            
 521   3      #ifdef U8G2_WITH_FONT_ROTATION
 522   3            switch(decode->dir)
 523   3            {
 524   4        case 0:
 525   4            x1 += decode->glyph_width;
 526   4            y1 += h;
 527   4            break;
 528   4        case 1:
 529   4            x0 -= h;
 530   4            x0++; /* shift down, because of assymetric boundaries for the interseciton test */
 531   4            x1++;
 532   4            y1 += decode->glyph_width;
 533   4            break;
 534   4        case 2:
 535   4            x0 -= decode->glyph_width;
 536   4            x0++; /* shift down, because of assymetric boundaries for the interseciton test */
 537   4            x1++;
 538   4            y0 -= h;
 539   4            y0++; /* shift down, because of assymetric boundaries for the interseciton test */
 540   4            y1++;
 541   4            break;    
 542   4        case 3:
C51 COMPILER V9.01   U8G2_FONT                                                             04/30/2021 10:55:17 PAGE 10  

 543   4            x1 += h;
 544   4            y0 -= decode->glyph_width;
 545   4            y0++; /* shift down, because of assymetric boundaries for the interseciton test */
 546   4            y1++;
 547   4            break;    
 548   4            }
 549   3      #else /* U8G2_WITH_FONT_ROTATION */
                    x1 += decode->glyph_width;
                    y1 += h;      
              #endif
 553   3            
 554   3            if ( u8g2_IsIntersection(u8g2, x0, y0, x1, y1) == 0 ) 
 555   3        return d;
 556   3          }
 557   2      #endif /* U8G2_WITH_INTERSECTION */
 558   2         
 559   2          /* reset local x/y position */
 560   2          decode->x = 0;
 561   2          decode->y = 0;
 562   2          
 563   2          /* decode glyph */
 564   2          for(;;)
 565   2          {
 566   3            a = u8g2_font_decode_get_unsigned_bits(decode, u8g2->font_info.bits_per_0);
 567   3            b = u8g2_font_decode_get_unsigned_bits(decode, u8g2->font_info.bits_per_1);
 568   3            do
 569   3            {
 570   4        u8g2_font_decode_len(u8g2, a, 0);
 571   4        u8g2_font_decode_len(u8g2, b, 1);
 572   4            } while( u8g2_font_decode_get_unsigned_bits(decode, 1) != 0 );
 573   3      
 574   3            if ( decode->y >= h )
 575   3        break;
 576   3          }
 577   2          
 578   2          /* restore the u8g2 draw color, because this is modified by the decode algo */
 579   2          u8g2->draw_color = decode->fg_color;
 580   2        }
 581   1        return d;
 582   1      }
 583          
 584          /*
 585            Description:
 586              Find the starting point of the glyph data.
 587            Args:
 588              encoding: Encoding (ASCII or Unicode) of the glyph
 589            Return:
 590              Address of the glyph data or NULL, if the encoding is not avialable in the font.
 591          */
 592          const uint8_t *u8g2_font_get_glyph_data(u8g2_t *u8g2, uint16_t encoding)
 593          {
 594   1        const uint8_t *font = u8g2->font;
 595   1        font += U8G2_FONT_DATA_STRUCT_SIZE;
 596   1      
 597   1        
 598   1        if ( encoding <= 255 )
 599   1        {
 600   2          if ( encoding >= 'a' )
 601   2          {
 602   3            font += u8g2->font_info.start_pos_lower_a;
 603   3          }
 604   2          else if ( encoding >= 'A' )
C51 COMPILER V9.01   U8G2_FONT                                                             04/30/2021 10:55:17 PAGE 11  

 605   2          {
 606   3            font += u8g2->font_info.start_pos_upper_A;
 607   3          }
 608   2          
 609   2          for(;;)
 610   2          {
 611   3            if ( u8x8_pgm_read( font + 1 ) == 0 )
 612   3        break;
 613   3            if ( u8x8_pgm_read( font ) == encoding )
 614   3            {
 615   4        return font+2;  /* skip encoding and glyph size */
 616   4            }
 617   3            font += u8x8_pgm_read( font + 1 );
 618   3          }
 619   2        }
 620   1      #ifdef U8G2_WITH_UNICODE
 621   1        else
 622   1        {
 623   2          uint16_t e;
 624   2          const uint8_t *unicode_lookup_table;
 625   2          
 626   2      // removed, there is now the new index table
 627   2      //#ifdef  __unix__
 628   2      //    if ( u8g2->last_font_data != NULL && encoding >= u8g2->last_unicode )
 629   2      //    {
 630   2      //  font = u8g2->last_font_data;
 631   2      //    }
 632   2      //    else
 633   2      //#endif 
 634   2      
 635   2          font += u8g2->font_info.start_pos_unicode;
 636   2          unicode_lookup_table = font; 
 637   2        
 638   2          /* issue 596: search for the glyph start in the unicode lookup table */
 639   2          do
 640   2          {
 641   3            font += u8g2_font_get_word(unicode_lookup_table, 0);
 642   3            e = u8g2_font_get_word(unicode_lookup_table, 2);
 643   3            unicode_lookup_table+=4;
 644   3          } while( e < encoding );
 645   2          
 646   2        
 647   2          for(;;)
 648   2          {
 649   3            e = u8x8_pgm_read( font );
 650   3            e <<= 8;
 651   3            e |= u8x8_pgm_read( font + 1 );
 652   3        
 653   3      // removed, there is now the new index table  
 654   3      //#ifdef  __unix__
 655   3      //      if ( encoding < e )
 656   3      //        break;
 657   3      //#endif 
 658   3      
 659   3            if ( e == 0 )
 660   3        break;
 661   3        
 662   3            if ( e == encoding )
 663   3            {
 664   4      // removed, there is now the new index table
 665   4      //#ifdef  __unix__
 666   4      //  u8g2->last_font_data = font;
C51 COMPILER V9.01   U8G2_FONT                                                             04/30/2021 10:55:17 PAGE 12  

 667   4      //  u8g2->last_unicode = encoding;
 668   4      //#endif 
 669   4        return font+3;  /* skip encoding and glyph size */
 670   4            }
 671   3            font += u8x8_pgm_read( font + 2 );
 672   3          }  
 673   2        }
 674   1      #endif
 675   1        
 676   1        return NULL;
 677   1      }
 678          
 679          static u8g2_uint_t u8g2_font_draw_glyph(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, uint16_t encoding)
 680          {
 681   1        u8g2_uint_t dx = 0;
 682   1        u8g2->font_decode.target_x = x;
 683   1        u8g2->font_decode.target_y = y;
 684   1        //u8g2->font_decode.is_transparent = is_transparent; this is already set
 685   1        //u8g2->font_decode.dir = dir;
 686   1        const uint8_t *glyph_data = u8g2_font_get_glyph_data(u8g2, encoding);
*** ERROR C141 IN LINE 686 OF ..\U8G2\CSRC\U8G2_FONT.C: syntax error near 'const'
*** ERROR C202 IN LINE 686 OF ..\U8G2\CSRC\U8G2_FONT.C: 'glyph_data': undefined identifier
 687   1        if ( glyph_data != NULL )
*** ERROR C202 IN LINE 687 OF ..\U8G2\CSRC\U8G2_FONT.C: 'glyph_data': undefined identifier
 688   1        {
 689   2          dx = u8g2_font_decode_glyph(u8g2, glyph_data);
*** ERROR C202 IN LINE 689 OF ..\U8G2\CSRC\U8G2_FONT.C: 'glyph_data': undefined identifier
 690   2        }
 691   1        return dx;
 692   1      }
 693          
 694          
 695          
 696          uint8_t u8g2_IsGlyph(u8g2_t *u8g2, uint16_t requested_encoding)
 697          {
 698   1        /* updated to new code */
 699   1        if ( u8g2_font_get_glyph_data(u8g2, requested_encoding) != NULL )
 700   1          return 1;
 701   1        return 0;
 702   1      }
 703          
 704          /* side effect: updates u8g2->font_decode and u8g2->glyph_x_offset */
 705          int8_t u8g2_GetGlyphWidth(u8g2_t *u8g2, uint16_t requested_encoding)
 706          {
 707   1        const uint8_t *glyph_data = u8g2_font_get_glyph_data(u8g2, requested_encoding);
 708   1        if ( glyph_data == NULL )
 709   1          return 0; 
 710   1        
 711   1        u8g2_font_setup_decode(u8g2, glyph_data);
 712   1        u8g2->glyph_x_offset = u8g2_font_decode_get_signed_bits(&(u8g2->font_decode), u8g2->font_info.bits_per_c
             -har_x);
 713   1        u8g2_font_decode_get_signed_bits(&(u8g2->font_decode), u8g2->font_info.bits_per_char_y);
 714   1        
 715   1        /* glyph width is here: u8g2->font_decode.glyph_width */
 716   1      
 717   1        return u8g2_font_decode_get_signed_bits(&(u8g2->font_decode), u8g2->font_info.bits_per_delta_x);
 718   1      }
 719          
 720          
 721          /*
 722            set one of:
 723              U8G2_FONT_MODE_TRANSPARENT
C51 COMPILER V9.01   U8G2_FONT                                                             04/30/2021 10:55:17 PAGE 13  

 724              U8G2_FONT_MODE_SOLID
 725              U8G2_FONT_MODE_NONE
 726            This has been changed for the new font procedures  
 727          */
 728          void u8g2_SetFontMode(u8g2_t *u8g2, uint8_t is_transparent)
 729          {
 730   1        u8g2->font_decode.is_transparent = is_transparent;    // new font procedures
 731   1      }
 732          
 733          u8g2_uint_t u8g2_DrawGlyph(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, uint16_t encoding)
 734          {
 735   1      #ifdef U8G2_WITH_FONT_ROTATION
 736   1        switch(u8g2->font_decode.dir)
 737   1        {
 738   2          case 0:
 739   2            y += u8g2->font_calc_vref(u8g2);
 740   2            break;
 741   2          case 1:
 742   2            x -= u8g2->font_calc_vref(u8g2);
 743   2            break;
 744   2          case 2:
 745   2            y -= u8g2->font_calc_vref(u8g2);
 746   2            break;
 747   2          case 3:
 748   2            x += u8g2->font_calc_vref(u8g2);
 749   2            break;
 750   2        }
 751   1      #else
                y += u8g2->font_calc_vref(u8g2);
              #endif
 754   1        return u8g2_font_draw_glyph(u8g2, x, y, encoding);
 755   1      }
 756          
 757          static u8g2_uint_t u8g2_draw_string(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, const char *str) U8G2_NOIN
             -LINE;
 758          static u8g2_uint_t u8g2_draw_string(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, const char *str)
 759          {
 760   1        uint16_t e;
 761   1        u8g2_uint_t delta, sum;
 762   1        u8x8_utf8_init(u8g2_GetU8x8(u8g2));
 763   1        sum = 0;
 764   1        for(;;)
 765   1        {
 766   2          e = u8g2->u8x8.next_cb(u8g2_GetU8x8(u8g2), (uint8_t)*str);
 767   2          if ( e == 0x0ffff )
 768   2            break;
 769   2          str++;
 770   2          if ( e != 0x0fffe )
 771   2          {
 772   3            delta = u8g2_DrawGlyph(u8g2, x, y, e);
 773   3          
 774   3      #ifdef U8G2_WITH_FONT_ROTATION
 775   3            switch(u8g2->font_decode.dir)
 776   3            {
 777   4        case 0:
 778   4          x += delta;
 779   4          break;
 780   4        case 1:
 781   4          y += delta;
 782   4          break;
 783   4        case 2:
 784   4          x -= delta;
C51 COMPILER V9.01   U8G2_FONT                                                             04/30/2021 10:55:17 PAGE 14  

 785   4          break;
 786   4        case 3:
 787   4          y -= delta;
 788   4          break;
 789   4            }
 790   3      #else
                    x += delta;
              #endif
 793   3      
 794   3            sum += delta;    
 795   3          }
 796   2        }
 797   1        return sum;
 798   1      }
 799          
 800          u8g2_uint_t u8g2_DrawStr(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, const char *str)
 801          {
 802   1        u8g2->u8x8.next_cb = u8x8_ascii_next;
 803   1        return u8g2_draw_string(u8g2, x, y, str);
 804   1      }
 805          
 806          /*
 807          source: https://en.wikipedia.org/wiki/UTF-8
 808          Bits  from    to      bytes Byte 1    Byte 2    Byte 3    Byte 4    Byte 5    Byte 6
 809            7   U+0000    U+007F    1     0xxxxxxx
 810          11  U+0080    U+07FF    2     110xxxxx  10xxxxxx
 811          16  U+0800    U+FFFF    3     1110xxxx  10xxxxxx  10xxxxxx
 812          21  U+10000   U+1FFFFF  4     11110xxx  10xxxxxx  10xxxxxx  10xxxxxx
 813          26  U+200000  U+3FFFFFF   5     111110xx  10xxxxxx  10xxxxxx  10xxxxxx  10xxxxxx
 814          31  U+4000000   U+7FFFFFFF  6     1111110x  10xxxxxx  10xxxxxx  10xxxxxx  10xxxxxx  10xxxxxx  
 815          */
 816          u8g2_uint_t u8g2_DrawUTF8(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, const char *str)
 817          {
 818   1        u8g2->u8x8.next_cb = u8x8_utf8_next;
 819   1        return u8g2_draw_string(u8g2, x, y, str);
 820   1      }
 821          
 822          
 823          
 824          u8g2_uint_t u8g2_DrawExtendedUTF8(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, uint8_t to_left, u8g2_kernin
             -g_t *kerning, const char *str)
 825          {
 826   1        u8g2->u8x8.next_cb = u8x8_utf8_next;
 827   1        uint16_t e_prev = 0x0ffff;
*** ERROR C141 IN LINE 827 OF ..\U8G2\CSRC\U8G2_FONT.C: syntax error near 'uint16_t'
*** ERROR C202 IN LINE 827 OF ..\U8G2\CSRC\U8G2_FONT.C: 'e_prev': undefined identifier
 828   1        uint16_t e;
*** ERROR C141 IN LINE 828 OF ..\U8G2\CSRC\U8G2_FONT.C: syntax error near 'uint16_t'
*** ERROR C202 IN LINE 828 OF ..\U8G2\CSRC\U8G2_FONT.C: 'e': undefined identifier
 829   1        u8g2_uint_t delta, sum, k;
*** ERROR C141 IN LINE 829 OF ..\U8G2\CSRC\U8G2_FONT.C: syntax error near 'u8g2_uint_t'
*** ERROR C202 IN LINE 829 OF ..\U8G2\CSRC\U8G2_FONT.C: 'delta': undefined identifier
 830   1        u8x8_utf8_init(u8g2_GetU8x8(u8g2));
 831   1        sum = 0;
*** ERROR C202 IN LINE 831 OF ..\U8G2\CSRC\U8G2_FONT.C: 'sum': undefined identifier
 832   1        for(;;)
 833   1        {
 834   2          e = u8g2->u8x8.next_cb(u8g2_GetU8x8(u8g2), (uint8_t)*str);
*** ERROR C202 IN LINE 834 OF ..\U8G2\CSRC\U8G2_FONT.C: 'e': undefined identifier
 835   2          if ( e == 0x0ffff )
*** ERROR C202 IN LINE 835 OF ..\U8G2\CSRC\U8G2_FONT.C: 'e': undefined identifier
 836   2            break;
C51 COMPILER V9.01   U8G2_FONT                                                             04/30/2021 10:55:17 PAGE 15  

 837   2          str++;
 838   2          if ( e != 0x0fffe )
*** ERROR C202 IN LINE 838 OF ..\U8G2\CSRC\U8G2_FONT.C: 'e': undefined identifier
 839   2          {
 840   3            delta = u8g2_GetGlyphWidth(u8g2, e);
*** ERROR C202 IN LINE 840 OF ..\U8G2\CSRC\U8G2_FONT.C: 'delta': undefined identifier
 841   3            
 842   3            if ( to_left )
 843   3            {
 844   4              k = u8g2_GetKerning(u8g2, kerning, e, e_prev);
*** ERROR C202 IN LINE 844 OF ..\U8G2\CSRC\U8G2_FONT.C: 'k': undefined identifier
 845   4        delta -= k;
*** ERROR C202 IN LINE 845 OF ..\U8G2\CSRC\U8G2_FONT.C: 'delta': undefined identifier
 846   4        x -= delta;
*** ERROR C202 IN LINE 846 OF ..\U8G2\CSRC\U8G2_FONT.C: 'delta': undefined identifier
 847   4            }
 848   3            else
 849   3            {
 850   4              k = u8g2_GetKerning(u8g2, kerning, e_prev, e);
*** ERROR C202 IN LINE 850 OF ..\U8G2\CSRC\U8G2_FONT.C: 'k': undefined identifier
 851   4        delta -= k;
*** ERROR C202 IN LINE 851 OF ..\U8G2\CSRC\U8G2_FONT.C: 'delta': undefined identifier
 852   4            }
 853   3            e_prev = e;
*** ERROR C202 IN LINE 853 OF ..\U8G2\CSRC\U8G2_FONT.C: 'e_prev': undefined identifier
 854   3      
 855   3            u8g2_DrawGlyph(u8g2, x, y, e);
*** ERROR C202 IN LINE 855 OF ..\U8G2\CSRC\U8G2_FONT.C: 'e': undefined identifier
 856   3            if ( to_left )
 857   3            {
 858   4            }
 859   3            else
 860   3            {
 861   4        x += delta;
*** ERROR C202 IN LINE 861 OF ..\U8G2\CSRC\U8G2_FONT.C: 'delta': undefined identifier
 862   4        x -= k;
*** ERROR C202 IN LINE 862 OF ..\U8G2\CSRC\U8G2_FONT.C: 'k': undefined identifier
 863   4            }
 864   3            
 865   3            sum += delta;    
*** ERROR C202 IN LINE 865 OF ..\U8G2\CSRC\U8G2_FONT.C: 'sum': undefined identifier
 866   3          }
 867   2        }
 868   1        return sum;
*** ERROR C202 IN LINE 868 OF ..\U8G2\CSRC\U8G2_FONT.C: 'sum': undefined identifier
 869   1      }
 870          
 871          u8g2_uint_t u8g2_DrawExtUTF8(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, uint8_t to_left, const uint16_t *
             -kerning_table, const char *str)
 872          {
 873   1        u8g2->u8x8.next_cb = u8x8_utf8_next;
 874   1        uint16_t e_prev = 0x0ffff;
*** ERROR C141 IN LINE 874 OF ..\U8G2\CSRC\U8G2_FONT.C: syntax error near 'uint16_t'
*** ERROR C202 IN LINE 874 OF ..\U8G2\CSRC\U8G2_FONT.C: 'e_prev': undefined identifier
 875   1        uint16_t e;
*** ERROR C141 IN LINE 875 OF ..\U8G2\CSRC\U8G2_FONT.C: syntax error near 'uint16_t'
*** ERROR C202 IN LINE 875 OF ..\U8G2\CSRC\U8G2_FONT.C: 'e': undefined identifier
 876   1        u8g2_uint_t delta, sum, k;
*** ERROR C141 IN LINE 876 OF ..\U8G2\CSRC\U8G2_FONT.C: syntax error near 'u8g2_uint_t'
*** ERROR C202 IN LINE 876 OF ..\U8G2\CSRC\U8G2_FONT.C: 'delta': undefined identifier
 877   1        u8x8_utf8_init(u8g2_GetU8x8(u8g2));
 878   1        sum = 0;
C51 COMPILER V9.01   U8G2_FONT                                                             04/30/2021 10:55:17 PAGE 16  

*** ERROR C202 IN LINE 878 OF ..\U8G2\CSRC\U8G2_FONT.C: 'sum': undefined identifier
 879   1        for(;;)
 880   1        {
 881   2          e = u8g2->u8x8.next_cb(u8g2_GetU8x8(u8g2), (uint8_t)*str);
*** ERROR C202 IN LINE 881 OF ..\U8G2\CSRC\U8G2_FONT.C: 'e': undefined identifier
 882   2          if ( e == 0x0ffff )
*** ERROR C202 IN LINE 882 OF ..\U8G2\CSRC\U8G2_FONT.C: 'e': undefined identifier
 883   2            break;
 884   2          str++;
 885   2          if ( e != 0x0fffe )
*** ERROR C202 IN LINE 885 OF ..\U8G2\CSRC\U8G2_FONT.C: 'e': undefined identifier
 886   2          {
 887   3            delta = u8g2_GetGlyphWidth(u8g2, e);
*** ERROR C202 IN LINE 887 OF ..\U8G2\CSRC\U8G2_FONT.C: 'delta': undefined identifier
 888   3            
 889   3            if ( to_left )
 890   3            {
 891   4              k = u8g2_GetKerningByTable(u8g2, kerning_table, e, e_prev);
*** ERROR C202 IN LINE 891 OF ..\U8G2\CSRC\U8G2_FONT.C: 'k': undefined identifier
 892   4        delta -= k;
*** ERROR C202 IN LINE 892 OF ..\U8G2\CSRC\U8G2_FONT.C: 'delta': undefined identifier
 893   4        x -= delta;
*** ERROR C202 IN LINE 893 OF ..\U8G2\CSRC\U8G2_FONT.C: 'delta': undefined identifier
 894   4            }
 895   3            else
 896   3            {
 897   4              k = u8g2_GetKerningByTable(u8g2, kerning_table, e_prev, e);
*** ERROR C202 IN LINE 897 OF ..\U8G2\CSRC\U8G2_FONT.C: 'k': undefined identifier
 898   4        delta -= k;
*** ERROR C202 IN LINE 898 OF ..\U8G2\CSRC\U8G2_FONT.C: 'delta': undefined identifier
 899   4            }
 900   3            e_prev = e;
*** ERROR C202 IN LINE 900 OF ..\U8G2\CSRC\U8G2_FONT.C: 'e_prev': undefined identifier
 901   3      
 902   3            if ( to_left )
 903   3            {
 904   4            }
 905   3            else
 906   3            {
 907   4        x += delta;
*** ERROR C202 IN LINE 907 OF ..\U8G2\CSRC\U8G2_FONT.C: 'delta': undefined identifier
 908   4            }
 909   3            u8g2_DrawGlyph(u8g2, x, y, e);
*** ERROR C202 IN LINE 909 OF ..\U8G2\CSRC\U8G2_FONT.C: 'e': undefined identifier
 910   3            if ( to_left )
 911   3            {
 912   4            }
 913   3            else
 914   3            {
 915   4        //x += delta;
 916   4        //x -= k;
 917   4            }
 918   3            
 919   3            sum += delta;    
*** ERROR C202 IN LINE 919 OF ..\U8G2\CSRC\U8G2_FONT.C: 'sum': undefined identifier
 920   3          }
 921   2        }
 922   1        return sum;
*** ERROR C202 IN LINE 922 OF ..\U8G2\CSRC\U8G2_FONT.C: 'sum': undefined identifier
 923   1      }
 924          
 925          
C51 COMPILER V9.01   U8G2_FONT                                                             04/30/2021 10:55:17 PAGE 17  

 926          
 927          /*===============================================*/
 928          
 929          /* set ascent/descent for reference point calculation */
 930          
 931          void u8g2_UpdateRefHeight(u8g2_t *u8g2)
 932          {
 933   1        if ( u8g2->font == NULL )
 934   1          return;
 935   1        u8g2->font_ref_ascent = u8g2->font_info.ascent_A;
 936   1        u8g2->font_ref_descent = u8g2->font_info.descent_g;
 937   1        if ( u8g2->font_height_mode == U8G2_FONT_HEIGHT_MODE_TEXT )
 938   1        {
 939   2        }
 940   1        else if ( u8g2->font_height_mode == U8G2_FONT_HEIGHT_MODE_XTEXT )
 941   1        {
 942   2          if ( u8g2->font_ref_ascent < u8g2->font_info.ascent_para )
 943   2            u8g2->font_ref_ascent = u8g2->font_info.ascent_para;
 944   2          if ( u8g2->font_ref_descent > u8g2->font_info.descent_para )
 945   2            u8g2->font_ref_descent = u8g2->font_info.descent_para;
 946   2        }
 947   1        else
 948   1        {
 949   2          if ( u8g2->font_ref_ascent < u8g2->font_info.max_char_height+u8g2->font_info.y_offset )
 950   2            u8g2->font_ref_ascent = u8g2->font_info.max_char_height+u8g2->font_info.y_offset;
 951   2          if ( u8g2->font_ref_descent > u8g2->font_info.y_offset )
 952   2            u8g2->font_ref_descent = u8g2->font_info.y_offset;
 953   2        }  
 954   1      }
 955          
 956          void u8g2_SetFontRefHeightText(u8g2_t *u8g2)
 957          {
 958   1        u8g2->font_height_mode = U8G2_FONT_HEIGHT_MODE_TEXT;
 959   1        u8g2_UpdateRefHeight(u8g2);
 960   1      }
 961          
 962          void u8g2_SetFontRefHeightExtendedText(u8g2_t *u8g2)
 963          {
 964   1        u8g2->font_height_mode = U8G2_FONT_HEIGHT_MODE_XTEXT;
 965   1        u8g2_UpdateRefHeight(u8g2);
 966   1      }
 967          
 968          void u8g2_SetFontRefHeightAll(u8g2_t *u8g2)
 969          {
 970   1        u8g2->font_height_mode = U8G2_FONT_HEIGHT_MODE_ALL;
 971   1        u8g2_UpdateRefHeight(u8g2);
 972   1      }
 973          
 974          /*===============================================*/
 975          /* callback procedures to correct the y position */
 976          
 977          u8g2_uint_t u8g2_font_calc_vref_font(U8X8_UNUSED u8g2_t *u8g2)
 978          {
 979   1        return 0;
 980   1      }
 981          
 982          void u8g2_SetFontPosBaseline(u8g2_t *u8g2)
 983          {
 984   1        u8g2->font_calc_vref = u8g2_font_calc_vref_font;
 985   1      }
 986          
 987          
C51 COMPILER V9.01   U8G2_FONT                                                             04/30/2021 10:55:17 PAGE 18  

 988          u8g2_uint_t u8g2_font_calc_vref_bottom(u8g2_t *u8g2)
 989          {
 990   1        return (u8g2_uint_t)(u8g2->font_ref_descent);
 991   1      }
 992          
 993          void u8g2_SetFontPosBottom(u8g2_t *u8g2)
 994          {
 995   1        u8g2->font_calc_vref = u8g2_font_calc_vref_bottom;
 996   1      }
 997          
 998          u8g2_uint_t u8g2_font_calc_vref_top(u8g2_t *u8g2)
 999          {
1000   1        u8g2_uint_t tmp;
1001   1        /* reference pos is one pixel above the upper edge of the reference glyph */
1002   1        tmp = (u8g2_uint_t)(u8g2->font_ref_ascent);
1003   1        tmp++;
1004   1        return tmp;
1005   1      }
1006          
1007          void u8g2_SetFontPosTop(u8g2_t *u8g2)
1008          {
1009   1        u8g2->font_calc_vref = u8g2_font_calc_vref_top;
1010   1      }
1011          
1012          u8g2_uint_t u8g2_font_calc_vref_center(u8g2_t *u8g2)
1013          {
1014   1        int8_t tmp;
1015   1        tmp = u8g2->font_ref_ascent;
1016   1        tmp -= u8g2->font_ref_descent;
1017   1        tmp /= 2;
1018   1        tmp += u8g2->font_ref_descent;  
1019   1        return tmp;
1020   1      }
1021          
1022          void u8g2_SetFontPosCenter(u8g2_t *u8g2)
1023          {
1024   1        u8g2->font_calc_vref = u8g2_font_calc_vref_center;
1025   1      }
1026          
1027          /*===============================================*/
1028          
1029          void u8g2_SetFont(u8g2_t *u8g2, const uint8_t  *font)
1030          {
1031   1        if ( u8g2->font != font )
1032   1        {
1033   2      //#ifdef  __unix__
1034   2      //  u8g2->last_font_data = NULL;
1035   2      //  u8g2->last_unicode = 0x0ffff;
1036   2      //#endif 
1037   2          u8g2->font = font;
1038   2          u8g2_read_font_info(&(u8g2->font_info), font);
1039   2          u8g2_UpdateRefHeight(u8g2);
1040   2          /* u8g2_SetFontPosBaseline(u8g2); */ /* removed with issue 195 */
1041   2        }
1042   1      }
1043          
1044          /*===============================================*/
1045          
1046          static uint8_t u8g2_is_all_valid(u8g2_t *u8g2, const char *str) U8G2_NOINLINE;
1047          static uint8_t u8g2_is_all_valid(u8g2_t *u8g2, const char *str)
1048          {
1049   1        uint16_t e;
C51 COMPILER V9.01   U8G2_FONT                                                             04/30/2021 10:55:17 PAGE 19  

1050   1        u8x8_utf8_init(u8g2_GetU8x8(u8g2));
1051   1        for(;;)
1052   1        {
1053   2          e = u8g2->u8x8.next_cb(u8g2_GetU8x8(u8g2), (uint8_t)*str);
1054   2          if ( e == 0x0ffff )
1055   2            break;
1056   2          str++;
1057   2          if ( e != 0x0fffe )
1058   2          {
1059   3            if ( u8g2_font_get_glyph_data(u8g2, e) == NULL )
1060   3        return 0;
1061   3          }
1062   2        }
1063   1        return 1;
1064   1      }
1065          
1066          uint8_t u8g2_IsAllValidUTF8(u8g2_t *u8g2, const char *str)
1067          {
1068   1        u8g2->u8x8.next_cb = u8x8_utf8_next;
1069   1        return u8g2_is_all_valid(u8g2, str);
1070   1      }
1071          
1072          
1073          /* string calculation is stilll not 100% perfect as it addes the initial string offset to the overall size
             - */
1074          static u8g2_uint_t u8g2_string_width(u8g2_t *u8g2, const char *str) U8G2_NOINLINE;
1075          static u8g2_uint_t u8g2_string_width(u8g2_t *u8g2, const char *str)
1076          {
1077   1        uint16_t e;
1078   1        u8g2_uint_t  w, dx;
1079   1        
1080   1        u8g2->font_decode.glyph_width = 0;
1081   1        u8x8_utf8_init(u8g2_GetU8x8(u8g2));
1082   1        
1083   1        /* reset the total width to zero, this will be expanded during calculation */
1084   1        w = 0;
1085   1        dx = 0;
1086   1      
1087   1        // printf("str=<%s>\n", str);
1088   1        
1089   1        for(;;)
1090   1        {
1091   2          e = u8g2->u8x8.next_cb(u8g2_GetU8x8(u8g2), (uint8_t)*str);
1092   2          if ( e == 0x0ffff )
1093   2            break;
1094   2          str++;
1095   2          if ( e != 0x0fffe )
1096   2          {
1097   3            dx = u8g2_GetGlyphWidth(u8g2, e);   /* delta x value of the glyph */
1098   3            w += dx;
1099   3          }
1100   2        }
1101   1        
1102   1        /* adjust the last glyph, check for issue #16: do not adjust if width is 0 */
1103   1        if ( u8g2->font_decode.glyph_width != 0 )
1104   1        {
1105   2          w -= dx;
1106   2          w += u8g2->font_decode.glyph_width;  /* the real pixel width of the glyph, sideeffect of GetGlyphWidth
             - */
1107   2          /* issue #46: we have to add the x offset also */
1108   2          w += u8g2->glyph_x_offset;  /* this value is set as a side effect of u8g2_GetGlyphWidth() */
1109   2        }
C51 COMPILER V9.01   U8G2_FONT                                                             04/30/2021 10:55:17 PAGE 20  

1110   1        // printf("w=%d \n", w);
1111   1        
1112   1        return w;  
1113   1      }
1114          
1115          static void u8g2_GetGlyphHorizontalProperties(u8g2_t *u8g2, uint16_t requested_encoding, uint8_t *w, int8_
             -t *ox, int8_t *dx)
1116          {
1117   1        const uint8_t *glyph_data = u8g2_font_get_glyph_data(u8g2, requested_encoding);
1118   1        if ( glyph_data == NULL )
1119   1          return; 
1120   1        
1121   1        u8g2_font_setup_decode(u8g2, glyph_data);
1122   1        *w = u8g2->font_decode.glyph_width;
1123   1        *ox =  u8g2_font_decode_get_signed_bits(&(u8g2->font_decode), u8g2->font_info.bits_per_char_x);
1124   1        u8g2_font_decode_get_signed_bits(&(u8g2->font_decode), u8g2->font_info.bits_per_char_y);
1125   1        *dx = u8g2_font_decode_get_signed_bits(&(u8g2->font_decode), u8g2->font_info.bits_per_delta_x);
1126   1      }
1127          
1128          /* u8g compatible GetStrX function */
1129          int8_t u8g2_GetStrX(u8g2_t *u8g2, const char *s)
1130          {
1131   1        uint8_t w;
1132   1        int8_t ox, dx;
1133   1        u8g2_GetGlyphHorizontalProperties(u8g2, *s, &w, &ox, &dx);
1134   1        return ox;
1135   1      }
1136          
1137          
1138          
1139          static u8g2_uint_t u8g2_calculate_exact_string_width(u8g2_t *u8g2, const char *str)
1140          {
1141   1      
1142   1        u8g2_uint_t  w;
1143   1        uint16_t enc;
1144   1        uint8_t gw; 
1145   1        int8_t ox, dx;
1146   1        
1147   1        /* reset the total minimal width to zero, this will be expanded during calculation */
1148   1        w = 0;
1149   1          
1150   1        
1151   1        /* check for empty string, width is already 0 */
1152   1        do
1153   1        {
1154   2          enc = u8g2->u8x8.next_cb(u8g2_GetU8x8(u8g2), (uint8_t)*str);
1155   2          str++;
1156   2        } while( enc == 0x0fffe );
1157   1        
1158   1        if ( enc== 0x0ffff )
1159   1           return w;
1160   1        
1161   1        /* get the glyph information of the first char. This must be valid, because we already checked for the e
             -mpty string */
1162   1        /* if *s is not inside the font, then the cached parameters of the glyph are all zero */
1163   1        u8g2_GetGlyphHorizontalProperties(u8g2, enc, &gw, &ox, &dx);  
1164   1      
1165   1        /* strlen(s) == 1:       width = width(s[0]) */
1166   1        /* strlen(s) == 2:       width = - offx(s[0]) + deltax(s[0]) + offx(s[1]) + width(s[1]) */
1167   1        /* strlen(s) == 3:       width = - offx(s[0]) + deltax(s[0]) + deltax(s[1]) + offx(s[2]) + width(s[2]) *
             -/
1168   1        
C51 COMPILER V9.01   U8G2_FONT                                                             04/30/2021 10:55:17 PAGE 21  

1169   1        /* assume that the string has size 2 or more, than start with negative offset-x */
1170   1        /* for string with size 1, this will be nullified after the loop */
1171   1        w = -ox;  
1172   1        for(;;)
1173   1        {
1174   2          
1175   2          /* check and stop if the end of the string is reached */
1176   2          do
1177   2          {
1178   3            enc = u8g2->u8x8.next_cb(u8g2_GetU8x8(u8g2), (uint8_t)*str);
1179   3            str++;
1180   3          } while( enc == 0x0fffe );
1181   2          if ( enc== 0x0ffff )
1182   2            break;
1183   2      
1184   2          u8g2_GetGlyphHorizontalProperties(u8g2, enc, &gw, &ox, &dx);  
1185   2          
1186   2          /* if there are still more characters, add the delta to the next glyph */
1187   2          w += dx;    
1188   2        }
1189   1        
1190   1        /* finally calculate the width of the last char */
1191   1        /* here is another exception, if the last char is a black, use the dx value instead */
1192   1        if ( enc != ' ' )
1193   1        {
1194   2          /* if g was not updated in the for loop (strlen() == 1), then the initial offset x gets removed */
1195   2          w += gw;
1196   2          w += ox;
1197   2        }
1198   1        else
1199   1        {
1200   2          w += dx;
1201   2        }
1202   1        
1203   1        
1204   1        return w;
1205   1        
1206   1      }
1207          
1208          
1209          
1210          
1211          
1212          u8g2_uint_t u8g2_GetStrWidth(u8g2_t *u8g2, const char *s)
1213          {
1214   1        u8g2->u8x8.next_cb = u8x8_ascii_next;
1215   1        return u8g2_string_width(u8g2, s);
1216   1      }
1217          
1218          u8g2_uint_t u8g2_GetExactStrWidth(u8g2_t *u8g2, const char *s)
1219          {
1220   1        u8g2->u8x8.next_cb = u8x8_ascii_next;
1221   1        return u8g2_calculate_exact_string_width(u8g2, s);
1222   1      }
1223          
1224          /*
1225          source: https://en.wikipedia.org/wiki/UTF-8
1226          Bits  from    to      bytes Byte 1    Byte 2    Byte 3    Byte 4    Byte 5    Byte 6
1227            7   U+0000    U+007F    1     0xxxxxxx
1228          11  U+0080    U+07FF    2     110xxxxx  10xxxxxx
1229          16  U+0800    U+FFFF    3     1110xxxx  10xxxxxx  10xxxxxx
1230          21  U+10000   U+1FFFFF  4     11110xxx  10xxxxxx  10xxxxxx  10xxxxxx
C51 COMPILER V9.01   U8G2_FONT                                                             04/30/2021 10:55:17 PAGE 22  

1231          26  U+200000  U+3FFFFFF   5     111110xx  10xxxxxx  10xxxxxx  10xxxxxx  10xxxxxx
1232          31  U+4000000   U+7FFFFFFF  6     1111110x  10xxxxxx  10xxxxxx  10xxxxxx  10xxxxxx  10xxxxxx  
1233          */
1234          u8g2_uint_t u8g2_GetUTF8Width(u8g2_t *u8g2, const char *str)
1235          {
1236   1        u8g2->u8x8.next_cb = u8x8_utf8_next;
1237   1        return u8g2_string_width(u8g2, str);
1238   1      }
1239          
1240          
1241          
1242          void u8g2_SetFontDirection(u8g2_t *u8g2, uint8_t dir)
1243          {
1244   1      #ifdef U8G2_WITH_FONT_ROTATION  
1245   1        u8g2->font_decode.dir = dir;
1246   1      #endif
1247   1      }
1248          

C51 COMPILATION COMPLETE.  0 WARNING(S),  50 ERROR(S)
